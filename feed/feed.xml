<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title>Goldius Software Company</title>
	<subtitle>Sharing is the key.</subtitle>
	
	<link href="https://goldius.org/feed/feed.xml" rel="self"/>
	<link href="https://goldius.org/"/>
	<updated>2020-10-09T00:00:00Z</updated>
	<id>https://goldius.org/</id>
	<author>
		<name>Aleksandar Zlatkovic</name>
		<email>goldius.jobs@gmail.com</email>
	</author>
	
	<entry>
		<title>Netty reloading SSL/TLS certificate</title>
		<link href="https://goldius.org/posts/nettyreloadablesslcertificate/"/>
		<updated>2020-10-09T00:00:00Z</updated>
		<id>https://goldius.org/posts/nettyreloadablesslcertificate/</id>
		<content type="html">&lt;p&gt;Security is hot topic these days. Data has to be protected. Regulations have to be followed. Encrypted is the buzzword and more often than not SSL/TLS is a way to do it.&lt;/p&gt;
&lt;p&gt;Setting SSL/TLS implies having valid CA signed certificate on the server.  Please check the previous post, &lt;a href=&quot;https://goldius.org/posts/casignednettysecuredchat/&quot;&gt;Netty SSL with CA signed certificates&lt;/a&gt;, for explanations on how to create SSL certificates and used them to run netty secured chat example.&lt;/p&gt;
&lt;p&gt;In addition more often than not security standards require for certificates to be reloaded periodically. To solve this some basic understanding of TLS handshake and Netty channel bootstrapping is required.&lt;/p&gt;
&lt;p&gt;Let’s begin…&lt;/p&gt;
&lt;h2 id=&quot;tls%2Fssl-handshake&quot;&gt;TLS/SSL handshake &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/nettyreloadablesslcertificate/#tls%2Fssl-handshake&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;TLS use symmetric encryption to encrypt and decrypt traffic between client and server. When negotiating the TLS session at some point client and server create the session key and use it for symmetric encryption.&lt;/p&gt;
&lt;p&gt;More details on how this handshake process works can be found in &lt;a href=&quot;https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/&quot;&gt;What is a TLS handshake?&lt;/a&gt; article on Cloudflare.&lt;/p&gt;
&lt;p&gt;We will skip the details here, but the important thing to note is the step #6 from mentioned article. This step states:&lt;br /&gt;
&lt;strong&gt;6. Session keys created&lt;/strong&gt;: &lt;em&gt;Both client and server generate session keys from the client random, the server random, and the premaster secret. They should arrive at the same results.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What this means is that certificate is only used for handshake and for creation of session key in process of establishing the session. Each new session will create new session key.&lt;/p&gt;
&lt;p&gt;Based on the above we can replace our server certificate at any time. Client that is already connected to server will not lose connection as it already negotiated session key. Later clients can handshake with new key loaded in the meantime. Both clients should be able to stay connected, regardless to the server cert used for TLS handshake.&lt;/p&gt;
&lt;p&gt;Following diagram shows two clients connecting to server with TLS cert reloaded:&lt;br /&gt;
&lt;img src=&quot;https://goldius.org/img/nettyreloadablesslcertificate/tls_reload.png&quot; alt=&quot;tls_reload&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;netty-server-bootstrapping&quot;&gt;Netty Server Bootstrapping &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/nettyreloadablesslcertificate/#netty-server-bootstrapping&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Netty server bootstrapping involves binding a process to a given port for each client that requests a connection. Each time a requests for a connection is received, netty server creates a channel and binds a port. In this process and when SSL is enabled, netty will load SSL engine. We can plugin our implementation of &lt;code&gt;SslContext&lt;/code&gt; here and take over the cert load process from disk or wherever the cert files are stored.&lt;/p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;Implementation &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/nettyreloadablesslcertificate/#implementation&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Implementation of the context is quite simple. Below is the important code that does what we need:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ReloadableSslContext extends SslContext {
    private SslContext sslContext;
    private SSLEngine sslEngine;

    public ReloadableSslContext() throws SSLException {
        Configuration cfg = ConfigFactory.create(Configuration.class);
        loadContext(cfg.serverCertPath(), cfg.serverKeyPath());
    }

    private void loadContext(String certPath, String keyPath) throws SSLException {
        InputStream keyCertChainIS = getClass().getResourceAsStream(certPath);
        InputStream keyIS =getClass().getResourceAsStream(keyPath);
        sslContext = SslContextBuilder.forServer(keyCertChainIS, keyIS).build();
    }

    public void reload(String certPath, String keyPath) throws SSLException {
        loadContext(certPath, keyPath);
    }
    .
    .
    .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: This code is not thread safe and is only shown as an example of design approach and not as production ready code.&lt;/p&gt;
&lt;h2 id=&quot;usage&quot;&gt;Usage &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/nettyreloadablesslcertificate/#usage&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Reloadable SSL context can be used when creating server channel same as any other SSLContext implementation.&lt;br /&gt;
Code example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void start() throws InterruptedException, SSLException {

    Configuration cfg = ConfigFactory.create(Configuration.class);

    sslCtx = new ReloadableSslContext();

    EventLoopGroup bossGroup = new NioEventLoopGroup(1);
    EventLoopGroup workerGroup = new NioEventLoopGroup();

    try {
        bootstrap = new ServerBootstrap();
        bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .handler(new LoggingHandler(LogLevel.INFO))
                .childHandler(new SecureChatServerInitializer(sslCtx));

        bootstrap.bind(cfg.port()).sync().channel().closeFuture().sync();
    } finally {
        bossGroup.shutdownGracefully();
        workerGroup.shutdownGracefully();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then the secure channel server initialiser uses it as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pipeline.addLast(sslCtx.newHandler(ch.alloc()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can call it to relaod certs any time we want, we just provide the path to cert files:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sslContext).reload(cfg.serverCertPath2(), cfg.serverKeyPath2())
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;demo&quot;&gt;Demo &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/nettyreloadablesslcertificate/#demo&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Checkout or download the sourece code from git: &lt;a href=&quot;https://github.com/atozncoder/netty_secured_chat/tree/relodable_ssl&quot;&gt;https://github.com/atozncoder/netty_secured_chat/tree/relodable_ssl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Use relodable_ssl branch.&lt;/p&gt;
&lt;p&gt;In a console run following 2 commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn clean package
java -jar target/netty_seccured_chat-1.0-SNAPSHOT-jar-with-dependencies.jar server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In second console run following 2 commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar target/netty_seccured_chat-1.0-SNAPSHOT-jar-with-dependencies.jar client
ssl reload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that connection message shows that server cert subject is: &lt;code&gt;Subject DN: CN=goldius.rd.netty.ssl.org&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ssl reload&lt;/code&gt; command will be handlen by server so that it would use diferent cert from that moment.&lt;/p&gt;
&lt;p&gt;In third console run following&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar target/netty_seccured_chat-1.0-SNAPSHOT-jar-with-dependencies.jar client
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the connection message and that it shows that cert subject changed to: &lt;code&gt;Subject DN: CN=goldius.rd.netty_2.ssl.org&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Test both clients connections by sending any message.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Netty SSL/TLS with CA signed certificates</title>
		<link href="https://goldius.org/posts/casignednettysecuredchat/"/>
		<updated>2020-10-01T00:00:00Z</updated>
		<id>https://goldius.org/posts/casignednettysecuredchat/</id>
		<content type="html">&lt;h2 id=&quot;server-certificate&quot;&gt;Server certificate &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/casignednettysecuredchat/#server-certificate&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the description of the &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;TLS&lt;/a&gt; protocol for &lt;a href=&quot;https://tools.ietf.org/html/rfc5246#page-47&quot;&gt;Server certificate&lt;/a&gt; it states that it&#39;s structure is a sequence (chain) of certificates where the servers&#39;s certificate MUST come first in the list. Each following certificate MUST directly certify the one preceding it. Image below taken from the &lt;a href=&quot;https://www.ssl.com/article/browsers-and-certificate-validation/&quot;&gt;Browsers and Certificate Validation&lt;/a&gt; shows this in more details:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://goldius.org/img/casignednettysecuredchat/certification_paths.png&quot; alt=&quot;cert_chain&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;create-the-certificates&quot;&gt;Create the certificates &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/casignednettysecuredchat/#create-the-certificates&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Process to create certificates that can be used for test application can be found &lt;a href=&quot;https://help.f-secure.com/product.html#business/threatshield/latest/en/concept_E8E015C30E05412190F22C5DFC36AC0B-threatshield-latest-en&quot;&gt;here&lt;/a&gt;. For our example just following steps are needed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.f-secure.com/product.html#business/threatshield/latest/en/task_50407934989D4923AB76367EA0E627CA-threatshield-latest-en&quot;&gt;Create a self-signed root CA certificate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.f-secure.com/product.html#business/threatshield/latest/en/task_9EF132D90B9241268DF4EC8CA5FADBBF-threatshield-latest-en&quot;&gt;Create an intermediate CA certificate for creating other certificates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.f-secure.com/product.html#business/threatshield/latest/en/task_D81B8959CD3643C5A9E8DD0E2A4EF32E-threatshield-latest-en&quot;&gt;Create a leaf certificate for the webserver of the web UI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please note that for real production system real CA cert is needed and not self signed one.&lt;/p&gt;
&lt;h2 id=&quot;configure-server-ssl-context&quot;&gt;Configure Server SSL context &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/casignednettysecuredchat/#configure-server-ssl-context&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once certs are created, we need to setup our application to use them. For server we need following files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server.key - Server public key.&lt;/li&gt;
&lt;li&gt;server.pem - Server private key.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we look our example folder structure, this is how it can be setup:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://goldius.org/img/casignednettysecuredchat/server_certs_folder_strucutre.png&quot; alt=&quot;server_certs_folder_strucutre&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Now if we configure path to the certs in our config file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server.cert.path=/certs/server/server.pem
server.key.path=/certs/server/server.key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: I am using &lt;a href=&quot;http://owner.aeonbits.org/&quot;&gt;OWNER&lt;/a&gt; for configuration. This is not required for netty SSL.&lt;/p&gt;
&lt;p&gt;Then the following code can be used to load SSL context for server:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InputStream keyCertChainIS = getClass().getResourceAsStream(cfg.serverCertPath());
InputStream keyIS = getClass().getResourceAsStream(cfg.serverKeyPath());
sslCtx = SslContextBuilder.forServer(keyCertChainIS, keyIS).build();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;configure-client-ssl-context&quot;&gt;Configure Client SSL context &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/casignednettysecuredchat/#configure-client-ssl-context&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We need to import our root CA to be trusted root CA to our client. We need:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rootCA.crt - Root CA cert file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In our example it is setup as follows:&lt;br /&gt;
&lt;img src=&quot;https://goldius.org/img/casignednettysecuredchat/client_ca_cert_folder_structure.png&quot; alt=&quot;client_ca_cert_folder_structure&quot; /&gt;&lt;/p&gt;
&lt;p&gt;And we load it with following code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final SslContext sslCtx = SslContextBuilder.forClient()
        .trustManager(getInputStream())
        .build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where we get the input stream as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (&amp;quot;classpath&amp;quot;.equalsIgnoreCase(cfg.sslStreamReader())) {
    return getClass().getResourceAsStream(cfg.clientCertPath());
} else {
    return new FileInputStream(cfg.clientCertPath());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we have path to cert in classpath configured as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;client.cert.path=/certs/client/rootCA.crt
ssl.stream.reader=classpath
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;complete-example-and-demo&quot;&gt;Complete example and demo &lt;a class=&quot;direct-link&quot; href=&quot;https://goldius.org/posts/casignednettysecuredchat/#complete-example-and-demo&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The complete sample code can be found here:&lt;a href=&quot;https://github.com/atozncoder/netty_secured_chat&quot;&gt;https://github.com/atozncoder/netty_secured_chat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It can be tested by performing following steps:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn clean package
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In one terminal start the server:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar target/netty_seccured_chat-1.0-SNAPSHOT-jar-with-dependencies.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In another terminal start a client:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java -jar target/netty_seccured_chat-1.0-SNAPSHOT-jar-with-dependencies.jar client
&lt;/code&gt;&lt;/pre&gt;
</content>
	</entry>
</feed>
